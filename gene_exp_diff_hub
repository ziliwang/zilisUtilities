#!/usr/bin/env python3

#filename: gene_exp_diff_hub.py3
# encoding: utf-8

import sys
import copy
from nested_dict import nested_dict
import re
import argparse

def parse_args():
    des_info='''
FUNCTION:
	gene_exp_diff_hub joins the information of reference genes and predicted genes by CNCI, and the class_code of cuffmerege, and
expression of each locus, and the gene_exp.diff file into a simple table.
    '''
    epilog_info='''
Additional Info:
    1. <class_code_ifo> format:
	 ---------------------------
	 cufflink_id	class_code
	 ---------------------------
	 XLOC_012521	  =,j,=
	2. <ref_gene_info> <predicted_gene_info> format:
	 -----------------------------------------------		
	 gene_id	gene_type gene_status gene_name
	 -----------------------------------------------		
	 ENSG00000222623.1 snRNA KNOWN RNU6-1100P	|
	 ENSG00000241599.1 lincRNA NOVEL RP11-34P13.9	| <ref_gene_info>
	 ENSG00000228463.4 lincRNA NOVEL AP006222.2	|
	 XLOC_001931 antisense_lncRNA predicted antisense_DPYD	|
	 XLOC_001955 antisense_lncRNA predicted antisense_SASS6	| <predicted_gene_info>
Author:
	Zili Wang
Contact: 
	wzlnot@gmail.com
STATE: 
	gene_exp_diff_hub is free software: you can redistribute it and/or
	modify it under the terms of the GNU General Public License as published 
	by the Free Software Foundation, either version 3 of the License, or (at 
	your option) any later version.
 '''
    parser = argparse.ArgumentParser(description=des_info,epilog=epilog_info,formatter_class=argparse.RawDescriptionHelpFormatter);
    parser.add_argument('-F','--cuffdiff', type=str, help='cuffdiff outdir path',required=True) 
    parser.add_argument('-c','--classcode',type=str,help='class code file',required=True)
    parser.add_argument('-r','--ref',type=str,help='reference gene model',required=True)
    parser.add_argument('-p','--preticted',type=str,help='preticted gene model',required=True)
    parser.add_argument('-t','--tags',nargs="+",type=str,help='tags in cuffdiff', required=True)
    parser.add_argument('-s','--samples',nargs="+",type=str,help='samples list, corresponding to 0 to n in read_groups.info',required=True)
    args = parser.parse_args()
    return args

def main():
    args = parse_args()
    gene_hd = open(args.cuffdiff+'/genes.read_group_tracking','r')
    diff_hd = open(args.cuffdiff+'/gene_exp.diff','r')
    sample = args.samples
    class_hd =open(args.classcode,'r')
    ref_hd =open(args.ref,'r')
    predicted_hd = open(args.preticted,'r')
    #store gene expression value into a dict
    exp = nested_dict()
    while True:
        line = gene_hd.readline()
        if line:
            #gene -> tags -> samplename = exp_value
            if line.split('\t')[2] == "replicate": continue
            exp[line.split('\t')[0]][line.split('\t')[1]][sample[int(line.split('\t')[2])]]=line.split('\t')[6]	#store FPKM into exp dict
        else:
            break
    gene_hd.close()
    exp_dic=copy.deepcopy(exp.to_dict())	#exp trans to basic dict obj and then deepcopy to exp_dic
    class_code={}		#class_code dict for class_code
    while True:
        line = class_hd.readline()
        if line:
            class_code[line.split(' ')[0]]=line.strip('\n').split(' ')[1]  #store to class_code dict
        else:
            break
    class_hd.close()
    ref_info={}	#store reference gene info.
    while True:
        line = ref_hd.readline().strip('\n')
        if line:
            ref_info[line.split(' ')[3]]=line.split(' ')   #value type is list
        else:
            break
    ref_hd.close()
    predicted_info={}	#store predicted gene info.
    while True:
        line = predicted_hd.readline().strip('\n')
        if line:
    	    predicted_info[line.split(' ')[0]]=line.split(' ')	#value type is list
        else:
            break
    predicted_hd.close()
    header = ['class_code','gene_id','gene_type','gene_status','gene_name'] 
    for i in args.tags:
        for j in sample:
            header += [i+'.'+j]
    print('\t'.join([diff_hd.readline().strip('\n')] + header ) ) #headline
    while True:
        line = diff_hd.readline()
        if line:
            #4,5 for tags
            (simple_one,simple_two) = (line.split('\t')[4],line.split('\t')[5])
            simple_one = [exp_dic[line.split('\t')[1]][simple_one][key] for key in sorted(exp_dic[line.split('\t')[1]][simple_one].keys())]	#FPKM in each samples
            simple_two = [exp_dic[line.split('\t')[1]][simple_two][key] for key in sorted(exp_dic[line.split('\t')[1]][simple_two].keys())]
            info_add=''	#define and clear
            if re.search(r'[jc=]',class_code[line.split('\t')[1]]):
                if re.search(r'[,]',line.split('\t')[2]):
                    id_item,type_item,status_item,name_item=[],[],[],[] 
                    for list_key in range(0,len(line.split('\t')[2].split(','))):
                        id_item += [ref_info[line.split('\t')[2].split(',')[list_key]][0]]
                        type_item += [ref_info[line.split('\t')[2].split(',')[list_key]][1]]
                        status_item += [ref_info[line.split('\t')[2].split(',')[list_key]][2]]
                        name_item += [ref_info[line.split('\t')[2].split(',')[list_key]][3]]
                        info_add = [','.join(id_item),','.join(type_item),','.join(status_item),','.join(name_item)]
                else:	
                    info_add=ref_info[line.split('\t')[2]]
            elif re.search(r'[uix]',class_code[line.split('\t')[1]]):
                info_add=predicted_info[line.split('\t')[1]]
            else:
                info_add=['null','null','null','null']
            print('\t'.join([line.strip('\n')] + [class_code[line.split('\t')[1]]] + info_add + simple_one + simple_two))
        else:
            break
    diff_hd.close()

if __name__ == '__main__':
    main()

